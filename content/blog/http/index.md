---
title: http笔记
date: "2022-07-20T17:20:32.169Z"
description: http日常小笔记，持续更新...
tags: ['计算机网络','http']
disqus: true
---
# 三次握手四次挥手

>https://juejin.cn/post/6844903958624878606
>[https://juejin.cn/post/6978733203062915103](https://juejin.cn/post/6978733203062915103)
## 三次握手

 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换`TCP窗口大小`信息。

## 四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

### 四次挥手释放连接时，等待2MSL的意义?

 

> **MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 
 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

# 跨域

[https://juejin.cn/post/6844903767226351623](https://juejin.cn/post/6844903767226351623)

## 同源策略

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 

**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。

###  **同源策略限制内容有：**

* Cookie、LocalStorage、IndexedDB 等存储性内容
* DOM 节点
* AJAX 请求发送后，结果被浏览器拦截了
 

但是有三个标签是允许跨域加载资源：

 

* `<img src=XXX>`
* `<link href=XXX>`
* `<script src=XXX>`
## 跨域解决方案

###  JSONP

**利用**`<script>`**标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。** 

### JSONP的实现流程

* 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
* 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
* 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。
* 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。
### CORS

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

### Node中间件代理(两次跨域)

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：

* 接受客户端请求 。
* 将请求 转发给服务器。
* 拿到服务器 响应 数据。
* 将 响应 转发给客户端。
# 强缓存和协商缓存

## web缓存描述 ：

 

Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。（此结论来自http权威指南）

 

## 缓存的优缺点：

 

优点：

 

* 缓存减少了冗余的数据传输，节省了你的网络费用。
* 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。
* 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。
* 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。
 

缺点：

 

* 缓存中的数据可能与服务器的数据不一致；
* 消耗内存；
## 强缓存

>[https://juejin.cn/post/6844903736196726798](https://juejin.cn/post/6844903736196726798)
>[https://juejin.cn/post/6974529351270268958](https://juejin.cn/post/6974529351270268958)
### 强缓存又分为Expires 和 Cache-Control

Expires,该值是一个GMT时间格式个字符串，浏览器进行第一次请求时，服务器会在返回头部加上Expires，下次请求，如果在这个时间之前则命中缓存，

Cache-Control ，该值是利用max-age判断缓存的生命周期，是以秒为单位，如何在生命周期时间内，则命中缓存。

## 协商缓存

 

协商缓存利用Last-Modified , If-Modified-Since 和 ETag , If-None-Match来实现

 

Last-Modified , If-Modified-Since

 Last-Modified： 表示为为实体头部部分，response返回，表示为资源的最后更新时间 

 If-Modified-Since：通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源

ETag , If-None-Match

 有些情况下仅判断最后修改日期来验证资源是否有改动是不够的：

 1，存在周期性重写某些资源，但资源实际包含的内容并无变化；

 2，被修改的信息并不重要，如注释等；

 3，Last-Modified无法精确到毫秒，但有些资源更新频率有时会小于一秒。

 

 ETag:为相应头部字段，表示资源内容的唯一标识，随服务器response返回； 

 If-None-Match: 服务器比较请求头中的If-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，浏览器从缓存中读取资源，如果修改过，服务器会返回新的etag，并返回资源；

不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者 后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒 数，而不是绝对时间来表示过期时间。

 

ETag解决了Last-Modified使用时可能出现的资源的时间戳变了但内容没变及如果再一秒钟以内资源变化但Last-Modified没变的问题，感觉ETag更加稳妥。

 补充：根据浏览器缓存策略，Expire和Cache-Control用回车、后退、F5刷新会跳过本地缓存，每次都会从服务器中获数据。


# Get Post请求差异

[https://juejin.cn/post/6992933721703710750](https://juejin.cn/post/6992933721703710750)

# http状态码

[https://juejin.cn/post/7030428038953173029](https://juejin.cn/post/7030428038953173029)


 

 

